import{_ as n,p as s,q as l,s as t,R as e,Z as o}from"./framework-47a2e622.js";const i="/images/微信图片_20220905112333.png",c="/images/微信图片_20220905112513.png",r="/images/微信图片_20220905112805.png",h="/images/微信图片_20220905114900.png",a={},d=t("h2",{id:"漏洞简介",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#漏洞简介","aria-hidden":"true"},"#"),e(" 漏洞简介")],-1),p=t("p",null,"非法字符空格和截止符（\\0）会导致 Nginx 解析 URL 时的有限状态机混乱，此漏洞可导致目录跨越及代码执行。",-1),x=t("div",{class:"custom-container info"},[t("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[t("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[t("circle",{cx:"12",cy:"12",r:"9"}),t("path",{d:"M12 8h.01"}),t("path",{d:"M11 12h1v4h1"})])]),t("p",{class:"custom-container-title"},"影响版本"),t("ul",{class:"contains-task-list"},[t("li",{class:"task-list-item"},[t("input",{class:"task-list-item-checkbox",checked:"",disabled:"",type:"checkbox"}),e(" Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7")])])],-1),_=t("h2",{id:"漏洞复现",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#漏洞复现","aria-hidden":"true"},"#"),e(" 漏洞复现")],-1),u=t("p",null,"使用 docker 搭建环境：",-1),g=t("p",null,[t("img",{src:i,alt:""})],-1),w=t("p",null,"上传文件，并在文件名的后面加上一个空格：",-1),m=t("p",null,[t("img",{src:c,alt:""})],-1),k=t("div",{class:"custom-container tip"},[t("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[t("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[t("circle",{cx:"12",cy:"12",r:"9"}),t("path",{d:"M12 8h.01"}),t("path",{d:"M11 12h1v4h1"})])]),t("p",{class:"custom-container-title"},"提示"),t("p",null,"如果是 Windows 系统，文件名后面不需要空格，因为系统读取文件时会自动将空格删去。")],-1),v=t("p",null,"由于浏览器会自动进行 URL 编码，所以我们需要抓包访问。",-1),f=t("p",null,"访问路径：http://localhost/uploadfiles/shell.jpg[0x20][0x00].php",-1),y=t("p",null,[t("img",{src:r,alt:""})],-1),b=t("p",null,"可以看到 jpg 文件被解析成 php 文件。",-1),N=t("div",{class:"custom-container tip"},[t("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[t("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[t("circle",{cx:"12",cy:"12",r:"9"}),t("path",{d:"M12 8h.01"}),t("path",{d:"M11 12h1v4h1"})])]),t("p",{class:"custom-container-title"},"关于"),t("p",null,[e("在 ascii 码中没有 \\0 这个选项，但是在 ascii 编码中，有一个 "),t("code",null,"0x00"),e(" 表示 null，这个 null 就相当于是 \\0 的功能。")])],-1),M=o('<table><thead><tr><th style="text-align:center;">Bin(二进制)</th><th style="text-align:center;">Oct(八进制)</th><th style="text-align:center;">Dec(十进制)</th><th style="text-align:center;">Hex(十六进制)</th><th style="text-align:center;">缩写/字符</th><th style="text-align:center;">解释</th></tr></thead><tbody><tr><td style="text-align:center;">0000 0000</td><td style="text-align:center;">00</td><td style="text-align:center;">0</td><td style="text-align:center;">0x00</td><td style="text-align:center;">NUL(null)</td><td style="text-align:center;">空字符</td></tr></tbody></table><h2 id="漏洞原理" tabindex="-1"><a class="header-anchor" href="#漏洞原理" aria-hidden="true">#</a> 漏洞原理</h2><p>Nginx 会将读取到的 php 文件交给 fastcgi 解析，在 Nginx 的配置文件中可以看到如下配置：</p>',3),B=t("div",{class:"custom-container tip"},[t("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[t("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[t("circle",{cx:"12",cy:"12",r:"9"}),t("path",{d:"M12 8h.01"}),t("path",{d:"M11 12h1v4h1"})])]),t("p",{class:"custom-container-title"},"提示"),t("p",null,"Nginx 在 Linux 下的默认路径是：/usr/local/nginx/conf/nginx.conf")],-1),j=t("p",null,[t("img",{src:h,alt:""})],-1),C=t("p",null,"大部分情况下，网站是不允许直接上传 php 文件的，所以一般都是通过上传图片格式的文件，在图片中添加恶意代码，利用服务器的错误配置或者解析漏洞 getshell。这里是利用了一些让服务器做出一些错误的判断的操作，误认为这个文件就是 php 的文件，自然而然服务器就会把文件当作 php 的文件去执行。",-1),L=t("div",{class:"custom-container tip"},[t("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[t("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[t("circle",{cx:"12",cy:"12",r:"9"}),t("path",{d:"M12 8h.01"}),t("path",{d:"M11 12h1v4h1"})])]),t("p",{class:"custom-container-title"},"知识点"),t("p",null,"在正则表达式中如果遇到了 \\0 是不会停止匹配的，但是 Nginx 会停止。这个 \\0 叫做截断符，可以理解为结束符，就是如果我们使用非法的字符空格和截断符会使 Nginx 解析 URL 的时候状态混乱，这样我们就可以通过一个非编码空格绕过后缀名的限制。")],-1),R=t("p",null,"我们可以通过一个简单的例子说明：在服务器中有一个文件“shell.txt ”，文件名的最后面有一个空格，正确读取该文件的路径应该是 /*/shell.txt，这是如果我们用路径 /*/shell.txt \\0.php 读取的话，相当于在路径的后面添加了一个空格和一个截断符号，这回导致状态机制混乱，服务器会认为 shell.txt 是文件名，而后面的 php 是文件格式，由于他们是非法空格和截断符，所以他们不参与文件名和文件格式解析，从而造成原本应该是按照 txt 格式读取文件的方式变成了按照 php 读取文件的方式，也就造成了解析漏洞。",-1),U=t("h2",{id:"漏洞修复",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#漏洞修复","aria-hidden":"true"},"#"),e(" 漏洞修复")],-1),V=t("ul",null,[t("li",null,"php-fpm.conf 中的 security.limit_extensions 后面的值设置为 .php。")],-1),q=[d,p,x,_,u,g,w,m,k,v,f,y,b,N,M,B,j,C,L,R,U,V];function D(E,H){return s(),l("div",null,q)}const S=n(a,[["render",D],["__file","2.html.vue"]]);export{S as default};
