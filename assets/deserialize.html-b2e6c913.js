import{_ as s,p as n,q as l,Z as e,s as t,R as a}from"./framework-47a2e622.js";const o={},i=e(`<h2 id="漏洞原理" tabindex="-1"><a class="header-anchor" href="#漏洞原理" aria-hidden="true">#</a> 漏洞原理</h2><p>当程序在进行反序列化时，会自动调用一些函数，例如<code>__wakeup()</code>,<code>__destruct()</code>等函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些恶意代码到函数中，从而导致反序列化漏洞。</p><h2 id="漏洞危害" tabindex="-1"><a class="header-anchor" href="#漏洞危害" aria-hidden="true">#</a> 漏洞危害</h2><ul><li>攻击者可利用该漏洞远程执行命令。</li><li>攻击者可利用该漏洞上传 shell，并获取系统权限。</li></ul><h2 id="修复建议" tabindex="-1"><a class="header-anchor" href="#修复建议" aria-hidden="true">#</a> 修复建议</h2><ul><li>不要把用户的输入或者是用户可控的参数直接放进反序列化的操作中去。</li><li>在进入反序列化函数之前,对参数进行限制过滤。</li></ul><h2 id="原理解析" tabindex="-1"><a class="header-anchor" href="#原理解析" aria-hidden="true">#</a> 原理解析</h2><ul><li>[序列化]：将对象转化为字节流，便于保存在文件，内存，数据库中。</li><li>[反序列化]：字节流转化为对象。</li></ul><p>序列化对象：</p><div class="language-php" data-ext="php"><pre class="language-php"><code><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token keyword">class</span> <span class="token class-name-definition class-name">whatDo</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token variable">$x</span> <span class="token operator">=</span> <span class="token string double-quoted-string">&quot;imz&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> <span class="token variable">$y</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token variable">$obj</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">whatDo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">echo</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$obj</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter important">?&gt;</span></span>
</code></pre></div><p>输出结果：</p><div class="language-html" data-ext="html"><pre class="language-html"><code>O:6:&quot;whatDo&quot;:2:{s:1:&quot;x&quot;;s:3:&quot;imz&quot;;s:1:&quot;y&quot;;i:10;}
</code></pre></div><h2 id="php-反序列化" tabindex="-1"><a class="header-anchor" href="#php-反序列化" aria-hidden="true">#</a> PHP 反序列化</h2><blockquote><p>PHP 通过 <strong>serialize()</strong> 与 <strong>unserialize()</strong> 实现序列化与反序列化。</p></blockquote><p>常见的反序列化漏洞中出现的魔术方法及其触发条件：</p><table><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">条件</th></tr></thead><tbody><tr><td style="text-align:left;">__construct()</td><td style="text-align:left;">当一个对象创建时被调用</td></tr><tr><td style="text-align:left;">__destruct()</td><td style="text-align:left;">当一个对象销毁时被调用</td></tr><tr><td style="text-align:left;">__toString()</td><td style="text-align:left;">当一个对象被当作一个字符串时使用</td></tr><tr><td style="text-align:left;">__sleep()</td><td style="text-align:left;">在对象在被序列化之前运行</td></tr><tr><td style="text-align:left;">__wakeup()</td><td style="text-align:left;">如果有，在反序列化之前调用</td></tr></tbody></table>`,16),r=t("div",{class:"custom-container tip"},[t("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[t("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[t("circle",{cx:"12",cy:"12",r:"9"}),t("path",{d:"M12 8h.01"}),t("path",{d:"M11 12h1v4h1"})])]),t("p",{class:"custom-container-title"},"提示"),t("p",null,"序列化只序列化属性，不序列化方法。")],-1),c=e('<h3 id="原因分析" tabindex="-1"><a class="header-anchor" href="#原因分析" aria-hidden="true">#</a> 原因分析</h3><ul><li><code>unserialize()</code>传入参数可控。</li><li>存在某些魔术方法可用。</li><li>没有过滤或者过滤不完善。</li></ul><h2 id="java-反序列化" tabindex="-1"><a class="header-anchor" href="#java-反序列化" aria-hidden="true">#</a> JAVA 反序列化</h2><p>JAVA 通过 <strong>Java.io.ObjectOutputStream</strong> 和 <strong>Java.io.ObjectInputStream</strong> 两个类，通过<code>writeObject()</code>和<code>readObject()</code>方法实现序列化和反序列化。</p>',4),p=t("div",{class:"custom-container tip"},[t("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[t("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[t("circle",{cx:"12",cy:"12",r:"9"}),t("path",{d:"M12 8h.01"}),t("path",{d:"M11 12h1v4h1"})])]),t("p",{class:"custom-container-title"},"提示"),t("p",null,[a("实现"),t("code",null,"Serializable"),a("和"),t("code",null,"Externalizable"),a("接口的类的对象才能被序列化。")])],-1),d=[i,r,c,p];function h(u,k){return n(),l("div",null,d)}const x=s(o,[["render",h],["__file","deserialize.html.vue"]]);export{x as default};
