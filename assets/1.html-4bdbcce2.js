import{_ as n,p as s,q as p,s as t,R as e,Z as a}from"./framework-47a2e622.js";const o="/images/微信图片_20220905103533.png",i="/images/微信图片_20220905103701.png",c="/images/微信图片_20220905103836.png",r="/images/微信图片_20220905104648.png",l={},h=t("h2",{id:"漏洞简介",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#漏洞简介","aria-hidden":"true"},"#"),e(" 漏洞简介")],-1),d=t("p",null,"Nginx 是一款轻量级的 web 服务器、反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在 BSD-like 协议下发行。其特点是占有内存少，并发能力强。Nginx 中存在解析漏洞，使得攻击者可以使用任意格式的文件获取网站权限。",-1),_=t("div",{class:"custom-container tip"},[t("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[t("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[t("circle",{cx:"12",cy:"12",r:"9"}),t("path",{d:"M12 8h.01"}),t("path",{d:"M11 12h1v4h1"})])]),t("p",{class:"custom-container-title"},"提示"),t("p",null,"该漏洞与版本无关，是配置错误导致的。")],-1),g=a('<h2 id="漏洞复现" tabindex="-1"><a class="header-anchor" href="#漏洞复现" aria-hidden="true">#</a> 漏洞复现</h2><p>使用 docker 搭建环境：</p><p><img src="'+o+`" alt=""></p><p>创建一个 <code>shell.jpg</code> 文件，文件内容如下：</p><div class="language-php" data-ext="php"><pre class="language-php"><code>GIF89
<span class="token php language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter important">?&gt;</span></span>
</code></pre></div><p><img src="`+i+'" alt=""></p><p>通过返回的路径访问该文件，利用解析漏洞，在路径的后面加上 <code>/xxx.php</code>：</p><p><img src="'+c+'" alt=""></p><p>可以看到 jpg 文件被解析成了 php 格式的文件。</p><h2 id="漏洞原理" tabindex="-1"><a class="header-anchor" href="#漏洞原理" aria-hidden="true">#</a> 漏洞原理</h2><p>在 php 中，有一个选项，叫做 <code>cgi.fix_pathinfo</code>：</p><p><img src="'+r+'" alt=""></p><p>这个选项开启之后，php 会执行路径解析，举个简单的例子：在 php 中，如果收到一个文件的路径为： /test1.aa/test2.bb/test3.cc，那么 php 会先从<mark>最后</mark>开始解析，也就是说如果 test3.cc 不存在，那么会往前解析 test2.bb，<strong>如果 test2.bb 存在的话，那么会按照 test3.cc 的文件格式去解析 test2.bb</strong>。为什么说是 Nginx 中的漏洞？因为 Nginx 拿到 URL 的时候，会先去解析里面的文件路径，如果发现文件格式是 php 的话，会直接交给 php 去处理。</p>',13),u=t("div",{class:"custom-container tip"},[t("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[t("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[t("circle",{cx:"12",cy:"12",r:"9"}),t("path",{d:"M12 8h.01"}),t("path",{d:"M11 12h1v4h1"})])]),t("p",{class:"custom-container-title"},"Apache"),t("p",null,"与 Nginx 不同的是，Apache 会先验证路径存不存在再交给 php 处理，所以就不存在上述的问题。")],-1),m=t("h2",{id:"漏洞修复",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#漏洞修复","aria-hidden":"true"},"#"),e(" 漏洞修复")],-1),x=t("ul",null,[t("li",null,"将 php.ini 文件中的 cgi.fix_pathinfo 的值设置为 0。"),t("li",null,"php-fpm.conf 中的 security.limit_extensions 后面的值设置为 .php。")],-1),k=[h,d,_,g,u,m,x];function f(w,v){return s(),p("div",null,k)}const N=n(l,[["render",f],["__file","1.html.vue"]]);export{N as default};
