import{_ as t,p as e,q as a,Z as s}from"./framework-548e1e2a.js";const l="/images/namespace.png",n="/images/image-20220512160741828.png",r="/images/image-20220512165740764.png",p="/images/image-20220513114639726.png",o="/images/image-20220513093855075.png",c={},i=s('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><blockquote><p>容器是一种沙盒技术，是一种内核轻量级的操作系统层虚拟化技术，主要目的是为了将应用运行在其中，与外界隔离，及方便这个沙盒可以被转移到其它宿主机器。本质上，它是一个特殊的进程。通过名称空间（<mark>Namespace</mark>）、控制组（<mark>Control groups</mark>）、切根（<mark>chroot</mark>）技术把资源、文件、设备、状态和配置划分到一个独立的空间。</p></blockquote><p>通俗点的理解就是一个装应用软件的箱子，箱子里面有软件运行所需的依赖库和配置。开发人员可以把这个箱子搬到任何机器上，且不影响里面软件的运行。</p><h2 id="linux-容器" tabindex="-1"><a class="header-anchor" href="#linux-容器" aria-hidden="true">#</a> Linux 容器</h2><blockquote><p>Linux 容器主要由 <strong>namespace</strong> 和 <strong>cgroups</strong> 两大机制来保证实现。</p></blockquote><ul><li>Docker 容器本质是宿主机的进程。</li><li>通过 Namespace 实现资源隔离。</li><li>通过 Cgroups 实现了资源限制。</li></ul><h3 id="namespace" tabindex="-1"><a class="header-anchor" href="#namespace" aria-hidden="true">#</a> namespace</h3><p>namespace 是对系统资源的一种封装，可以使得进程看起来拥有独立的资源一样，可以用 namespace 技术来实现容器。命名空间将全局资源抽象，命名空间内部的进程看起来拥有一个全局资源实际上是一个<strong>隔离资源</strong>，命名空间内的变动<strong>同命名空间进程可感知，不同不可感知</strong>。</p><table><thead><tr><th style="text-align:left;">命名空间</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;">Mount</td><td style="text-align:left;">隔离文件系统挂载点</td></tr><tr><td style="text-align:left;">UTS</td><td style="text-align:left;">隔离主机名，实际隔离<code>nodename</code>和<code>domainname</code></td></tr><tr><td style="text-align:left;">IPC</td><td style="text-align:left;">隔离进程间通信、信号量和消息队列等</td></tr><tr><td style="text-align:left;">PID</td><td style="text-align:left;">隔离进程ID空间</td></tr><tr><td style="text-align:left;">Network</td><td style="text-align:left;">隔离网络包括网络接口、驱动、路由表、防火墙等</td></tr><tr><td style="text-align:left;">User</td><td style="text-align:left;">隔离 UserID 和 GroupID 以及其对应的能力</td></tr></tbody></table><p>namespace 有<mark>三个系统调用</mark>可以使用。</p><ul><li><code>clone()</code>：实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。</li><li><code>unshare()</code>：使某个进程脱离某个 namespace。</li><li><code>setns(int fd, int nstype)</code>：把某个进程加入到某个 namespace。</li></ul><h4 id="理解" tabindex="-1"><a class="header-anchor" href="#理解" aria-hidden="true">#</a> 理解</h4><p>实际上，即使用户没有手动创建 Linux Namespace，Linux 系统开机后也会创建一个默认的 Namespace，称为 <strong>root namespace</strong>，所有进程默认都运行在这个 Namespace 中，每个进程都认为自己拥有该 Namespace 中的所有系统全局资源。</p><p><img src="'+l+`" alt=""></p><p>查看某个进程运行在哪一个 namespace 中，即该进程享有的独立资源来自哪一个 namespace：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># ps -ef 查看进程状况</span>
<span class="token comment"># ls -l /proc/&lt;PID&gt;/ns</span>
<span class="token function">ls</span> <span class="token parameter variable">-l</span> /proc/<span class="token variable">$$</span>/ns <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">&#39;{print $1,$(NF-2),$(NF-1),$NF}&#39;</span>
<span class="token function">sudo</span> <span class="token function">ls</span> <span class="token parameter variable">-l</span> /proc/1/ns <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">&#39;{print $1,$(NF-2),$(NF-1),$NF}&#39;</span>
</code></pre></div><p><img src="`+n+`" alt=""></p><p>每一个文件都是一个软链接，所指向的文件是一串格式特殊的名称。冒号后面中括号内的数值表示该 Namespace 的<code>inode</code>，如果不同进程的 namespace inode 相同，说明这些进程属于同一个 namespace。pid=$$表示当前shell进程。上图中每个进程都运行在多个 namespace 中，进程之间的 inode 相同，证明运行在相同的 namespace 中。</p><h3 id="cgroups" tabindex="-1"><a class="header-anchor" href="#cgroups" aria-hidden="true">#</a> cgroups</h3><p>cgroups 全称为<code>linux Control Group</code>，crgroups 为每种可以控制的资源定义了一个子系统，它的主要作用就是限制一个进程组能够使用cpu、内存、磁盘、带宽等资源的上限，提供以下功能：</p><ul><li>限制资源使用，各种子系统的资源限制。</li><li>优先级控制，cpu 使用、内存、磁盘 io 吞吐等。</li><li>资源使用报告，可以用来计费。</li><li>控制，挂起、恢复进程。</li></ul><p>cgroups 中的三个组件：</p><ul><li>cgroup</li></ul><p>对进程分组管理的一种机制,一个 cgroup 包含一组进程,并可以在这个 cgroup 上增加 Linux subsystem 的各种参数配置,将一组进程和一组 subsystem 的系统参数关联起来，<strong>可以理解为按照某种资源控制标准划分而成的任务组，包含一个或多个进程</strong>。</p><ul><li>subsystem</li></ul><p>一组资源控制的模块。</p><p>查看子系统：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">mount</span> <span class="token parameter variable">-t</span> cgroup
</code></pre></div><p><img src="`+r+`" alt=""></p><table><thead><tr><th style="text-align:left;">子系统名称</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">systemd</td><td style="text-align:left;">维护的自己使用子系统</td></tr><tr><td style="text-align:left;">cpuset</td><td style="text-align:left;">如果为多核 cpu，可以为 cgroups 中的任务分配单独的 cpu 和内存</td></tr><tr><td style="text-align:left;">hugetlb</td><td style="text-align:left;">主要针对于 HugeTLB 系统进行限制，这是一个大页文件系统</td></tr><tr><td style="text-align:left;">freezer</td><td style="text-align:left;">挂起或者恢复 cgroups 中的进程</td></tr><tr><td style="text-align:left;">memory</td><td style="text-align:left;">设置每个 cgroup 的内存限制以及产生内存资源报告</td></tr><tr><td style="text-align:left;">perf_event</td><td style="text-align:left;">可以监测属于某个特定的 group 的所有线程以及运行在特定 CPU 上的线程</td></tr><tr><td style="text-align:left;">pids</td><td style="text-align:left;">限制 cgroup 的进程数，里面有各种策略</td></tr><tr><td style="text-align:left;">net_cls,net_prio</td><td style="text-align:left;">标记 cgroups 中进程的网络数据包，可以使用 tc 模块（traffic control）对数据包进行控制</td></tr><tr><td style="text-align:left;">devices</td><td style="text-align:left;">控制进程能够访问某些设备</td></tr><tr><td style="text-align:left;">blkio</td><td style="text-align:left;">限制进程的块设备（磁盘、usb）的输入/输出存取限制</td></tr><tr><td style="text-align:left;">cpu</td><td style="text-align:left;">限制进程的 cpu 使用率</td></tr></tbody></table><p>每个 subsystem 会关联到定义了相应限制的 cgroup 上,并对这个 cgroup 中的进程做相应的限制和控制。</p><p>查看虚拟文件系统：</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /sys/fs/cgroup
<span class="token function">ls</span> <span class="token parameter variable">-l</span>
</code></pre></div><p><img src="`+p+'" alt=""></p><ul><li>hierarchy</li></ul><p>hierarchy 的功能是把一组 cgroup 串成一个树状结构,一个这样的树便是一个 hierarchy 。通过这种树状结构, groups 可以做到继承。</p><p>系统对一组进程使用<code>cgroup_1</code>进行 CPU 使用率的限制，而其中的进程2需要在基础上限制 I/O 速率，可以使用<code>cgroup_2</code>，它继承于 cgroup_1，即在限制 CPU 使用率的基础上限制进程2的 I/O 速率。</p><p><img src="'+o+'" alt=""></p>',38),d=[i];function g(u,m){return e(),a("div",null,d)}const f=t(c,[["render",g],["__file","containerTechnology.html.vue"]]);export{f as default};
